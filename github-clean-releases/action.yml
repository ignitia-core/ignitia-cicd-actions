name: "github-clean-releases"
description: |
  Cleans up GitHub releases and tags based on the current semantic version.
  Supports deleting prereleases (e.g., 1.2.3-alpha) and/or older non-prereleases.

inputs:
  token:
    description: "GitHub Personal Access Token"
    required: true

  semantic-version:
    description: "The current semantic version (e.g., 1.2.3)"
    required: true

  keep:
    description: "Number of full (non-prerelease) releases to retain"
    required: false
    default: "10"

  clean-prereleases:
    description: "Whether to delete prerelease versions like 1.2.3-alpha"
    required: false
    default: "true"

  clean-old-releases:
    description: "Whether to delete older full releases beyond the 'keep' count"
    required: false
    default: "true"

  repo:
    description: "GitHub repository in the form owner/repo (optional)"
    required: false
    default: ""

runs:
  using: "composite"
  steps:
    - name: Clean GitHub releases and tags
      shell: bash
      run: |
        set -e

        TOKEN="${{ inputs.token }}"
        SEMVER="${{ inputs.semantic-version }}"
        KEEP="${{ inputs.keep }}"
        CLEAN_PRERELEASES="${{ inputs.clean-prereleases }}"
        CLEAN_OLD_RELEASES="${{ inputs.clean-old-releases }}"
        REPO="${{ inputs.repo }}"

        if [ -z "$REPO" ]; then
          REPO="${{ github.repository }}"
        fi

        echo "Repository: $REPO"
        echo "Semantic version: $SEMVER"
        echo "Keep count: $KEEP"
        echo "Clean prereleases: $CLEAN_PRERELEASES"
        echo "Clean old releases: $CLEAN_OLD_RELEASES"

        echo "tag_name,id,is_prerelease" > releases.csv

        PAGE=1
        while true; do
          RESPONSE=$(curl -s -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$REPO/releases?per_page=100&page=$PAGE")

          if [ "$(echo "$RESPONSE" | jq '. | length')" -eq "0" ]; then
            break
          fi

          echo "$RESPONSE" | jq -r '.[] | "\(.tag_name),\(.id),\(.prerelease)"' >> releases.csv
          PAGE=$((PAGE + 1))
        done

        declare -A PRERELEASE_MAP
        declare -A NON_PRERELEASE_MAP

        while IFS=',' read -r TAG ID IS_PRERELEASE; do
          if [ "$TAG" = "tag_name" ]; then continue; fi

          # Strip "v" prefix if present
          STRIPPED_TAG="${TAG#v}"

          if [[ $(echo -e "$STRIPPED_TAG\n$SEMVER" | sort -V | tail -n1) == "$SEMVER" ]]; then
            if [[ "$STRIPPED_TAG" == *"-"* ]]; then
              PRERELEASE_MAP[$TAG]=$ID
            else
              NON_PRERELEASE_MAP[$TAG]=$ID
            fi
          fi
        done < releases.csv

        if [ "$CLEAN_PRERELEASES" == "true" ]; then
          echo "Cleaning prereleases..."
          for TAG in "${!PRERELEASE_MAP[@]}"; do
            ID=${PRERELEASE_MAP[$TAG]}
            echo "Deleting prerelease: $TAG (ID: $ID)"
            curl -s -X DELETE -H "Authorization: token $TOKEN" \
              "https://api.github.com/repos/$REPO/releases/$ID"
            curl -s -X DELETE -H "Authorization: token $TOKEN" \
              "https://api.github.com/repos/$REPO/git/refs/tags/$TAG"
          done
        fi

        if [ "$CLEAN_OLD_RELEASES" == "true" ]; then
          echo "Cleaning old non-prerelease releases beyond $KEEPâ€¦"
          NON_PRERELEASE_SORTED=($(printf '%s\n' "${!NON_PRERELEASE_MAP[@]}" | sort -rV))

          if [ ${#NON_PRERELEASE_SORTED[@]} -gt $KEEP ]; then
            for ((i=KEEP; i<${#NON_PRERELEASE_SORTED[@]}; i++)); do
              TAG=${NON_PRERELEASE_SORTED[$i]}
              ID=${NON_PRERELEASE_MAP[$TAG]}
              echo "Deleting old release: $TAG (ID: $ID)"
              curl -s -X DELETE -H "Authorization: token $TOKEN" \
                "https://api.github.com/repos/$REPO/releases/$ID"
              curl -s -X DELETE -H "Authorization: token $TOKEN" \
                "https://api.github.com/repos/$REPO/git/refs/tags/$TAG"
            done
          fi
        fi