name: 'Common Replace Placeholders'
description: 'Recursively replaces placeholders within all files in a given directory'
author: 'Ignitia'

inputs:
  directory:
    description: 'Root directory in which to perform replacements'
    required: false
    default: './'
  
  replacements-in:
    description: 'Placeholder keys to search for, separated by tilde (~)'
    required: true
  
  replacements-out:
    description: 'Replacement values, separated by tilde (~), must match the order of replacements-in'
    required: true

runs:
  using: 'composite'
  steps:
    - name: Replace placeholders in files
      shell: bash
      run: |
        set -euo pipefail
        
        TARGET_DIR="${{ inputs.directory }}"
        
        # Validate directory exists
        if [ ! -d "$TARGET_DIR" ]; then
          echo "‚ùå Error: Directory does not exist: $TARGET_DIR"
          exit 1
        fi
        
        cd "$TARGET_DIR"
        echo "Working directory: $(pwd)"
        echo ""
        
        # Parse replacement arrays
        IFS='~' read -ra SEARCH_TERMS <<< "${{ inputs.replacements-in }}"
        IFS='~' read -ra REPLACE_TERMS <<< "${{ inputs.replacements-out }}"
        
        # Validate matching counts
        if [ "${#SEARCH_TERMS[@]}" -ne "${#REPLACE_TERMS[@]}" ]; then
          echo "‚ùå Error: Mismatch in replacement counts"
          echo "   replacements-in:  ${#SEARCH_TERMS[@]} entries"
          echo "   replacements-out: ${#REPLACE_TERMS[@]} entries"
          exit 1
        fi
        
        # Validate non-empty arrays
        if [ "${#SEARCH_TERMS[@]}" -eq 0 ]; then
          echo "‚ùå Error: No replacement terms provided"
          exit 1
        fi
        
        echo "=========================================="
        echo "üîÑ Replacement Plan"
        echo "=========================================="
        for index in "${!SEARCH_TERMS[@]}"; do
          echo "$((index + 1)). '${SEARCH_TERMS[$index]}' ‚Üí '${REPLACE_TERMS[$index]}'"
        done
        echo ""
        
        # Perform replacements
        TOTAL_FILES_MODIFIED=0
        
        for index in "${!SEARCH_TERMS[@]}"; do
          SEARCH_TERM="${SEARCH_TERMS[$index]}"
          REPLACE_TERM="${REPLACE_TERMS[$index]}"
          
          echo "=========================================="
          echo "Processing: '${SEARCH_TERM}' ‚Üí '${REPLACE_TERM}'"
          echo "=========================================="
          
          # Validate search term is not empty
          if [ -z "$SEARCH_TERM" ]; then
            echo "‚ö†Ô∏è  Warning: Empty search term at position $((index + 1)), skipping"
            continue
          fi
          
          # Find files containing the search term and perform replacement
          echo "ÔøΩ Replacing '$SEARCH_TERM' with '$REPLACE_TERM'"
          
          # Use find + xargs safely (your proven approach)
          find . -type f -not -path '*/\.git/*' -not -path '*/.github/*' -exec grep -Il "$SEARCH_TERM" {} \; | xargs -r sed -i "s~$SEARCH_TERM~$REPLACE_TERM~g"
          
          # Count how many files were modified
          FILES_MODIFIED=$(find . -type f -not -path '*/\.git/*' -not -path '*/.github/*' -exec grep -l "$REPLACE_TERM" {} \; 2>/dev/null | wc -l)
          
          echo "‚úÖ Modified $FILES_MODIFIED file(s) for this replacement"
          ((TOTAL_FILES_MODIFIED += FILES_MODIFIED))
          echo ""
        done
        
        echo "=========================================="
        echo "üìä Summary"
        echo "=========================================="
        echo "Total replacements: ${#SEARCH_TERMS[@]}"
        echo "Total files modified: $TOTAL_FILES_MODIFIED"
        echo "‚úÖ Placeholder replacement complete"